import './ChessBackdrop.css'
import * as THREE from 'three'
import { AsciiEffect, initSplineTexture } from 'three/examples/jsm/Addons.js'
import { STLLoader } from 'three/examples/jsm/Addons.js';
import { degToRad } from 'three/src/math/MathUtils.js';
import pawnUrl from '../assets/pawn.stl';
import rookUrl from '../assets/rook.stl';
import kingUrl from '../assets/king.stl';

export default function ChessBackdrop() {
    let camera, controls, scene, renderer, effect;

    let pawn, rook, king;

    const start = Date.now();

    const material = new THREE.MeshPhongMaterial( { flatShading: true } );

    init();

    function init() {
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.x = 0.860;
        camera.position.y = 1.111;
        camera.position.z = -3.485;

        // camera.rotateX = 180;
        // camera.rotateZ = 180;
        camera.rotateX = Math.PI;
        camera.rotateZ = Math.PI;

        scene = THREE.Scene();
        // scene.background = new THREE.Color(0, 0, 0, 0);
        scene.background = new THREE.Color().setHex( 0x101010 );
        
        const pointLight1 = new THREE.PointLight( 0xFFFFFF, 3, 0, 0);
        pointLight1.position.set( 500, 500, 500 );
        scene.add( pointLight1 );
        
        const pointLight2 = new THREE.PointLight( 0xFFFFFF, 3, 0, 0);
        pointLight2.position.set( -500, -500, -500 );
        scene.add( pointLight2 );

        const loader = new STLLoader();

        loader.load(
            pawnUrl, function ( model ) {
                group = new THREE.Group();
                scene.add( group );
                pawn = new THREE.Mesh(model, material);
                pawn.position.set( 0.720, 0.785, 0 );
                pawn.rotation( degToRad(-75.62), degToRad(-8.46), degToRad(-8.01) );
                pawn.scale.set( 0.02, 0.02, 0.02 );
                pawn.castShadow = true;
                pawn.receiveShadow = true;

                model.center();
                group.add(model)
            }, undefined, function ( error ) {
                console.error( error );
            }
        );

        loader.load(
            rookUrl, function ( model ) {
                group = new THREE.Group();
                scene.add( group );
                rook = new THREE.Mesh(model, material);
                rook.position.set( 1.604, 1.525, 0.069 );
                rook.rotation( degToRad(-125.75), degToRad(-10.93), degToRad(-46.66) );
                rook.scale.set( 0.02, 0.02, 0.02 );
                rook.castShadow = true;
                rook.receiveShadow = true;

                model.center();
                group.add(model)
            }, undefined, function ( error ) {
                console.error( error );
            }
        );

        loader.load(
            kingUrl, function ( model ) {
                group = new THREE.Group();
                scene.add( group );
                king = new THREE.Mesh(model, material);
                king.position.set( -0.138, 1.818, 0 );
                king.rotation( degToRad(-72.47), degToRad(-22.59), degToRad(-3.49) );
                king.scale.set( 0.02, 0.02, 0.02 );
                king.castShadow = true;
                king.receiveShadow = true;

                model.center();
                group.add(model)
            }, undefined, function ( error ) {
                console.error( error );
            }
        );
        

        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );
        
        // TODO: renderer.animate( ... )
        
        console.log(`pawn: ${pawn}`)
        console.log(`rook: ${rook}`)
        console.log(`queen: ${queen}`)


        effect = new AsciiEffect( renderer, '.:-+*=%@#', { invert: true } );
        effect.setSize( window.innerWidth, window.innerHeight );
        effect.domElement.style.color = 'white';
        effect.domElement.style.backgroundColor = '#101010';

        effect.render( scene, camera );

        document.body.appendChild(effect.domElement);

    }
}
